////////////////////////////////////////////////////////////////////////////////
//
//    kernel.cfg : building file for MR308 Ver.4.00
//
//    Generated by M3T-MR308 GUI Configurator at 2021/12/17 16:48:55
//
////////////////////////////////////////////////////////////////////////////////

// system definition
system{
	stack_size	= 256;
	priority	= 10;
	system_IPL	 = 4;
	message_pri	 = 1;
	timeout	 = YES;
	task_pause	 = YES;
	tic_nume	 = 1;
	tic_deno	 = 1;
};

// max definition
maxdefine{
	max_task	= 11;
	max_flag	= 3;
	max_dtq	= 2;
	max_cyh	= 2;
	max_vdtq	= 1;
};

// system clock definition
clock{
	mpu_clock	= 20.000000MHz;
	timer	= A0;
	IPL	= 3;
};

task[]{
	entry_address	= main();
	name	= ID_main;
	stack_size	= 512;
	stack_section	= stack;
	priority	= 8;
	initial_start	= ON;
	exinf	= 0x0;
};
task[]{
	entry_address	= periph_tx();
	name	= ID_periph_tx;
	stack_size	= 256;
	stack_section	= stack;
	priority	= 3;
	initial_start	= ON;
	exinf	= 0x0;
};
task[]{
	entry_address	= periph_rx();
	name	= ID_periph_rx;
	stack_size	= 256;
	stack_section	= stack;
	priority	= 2;
	initial_start	= OFF;
	exinf	= 0x0;
};
task[]{
	entry_address	= regulation();
	name	= Id_regulation;
	stack_size	= 256;
	stack_section	= stack;
	priority	= 9;
	initial_start	= ON;
	exinf	= 0x0;
};
task[]{
	entry_address	= regulation_roue();
	name	= Id_regulation_roue;
	stack_size	= 256;
	stack_section	= stack;
	priority	= 9;
	initial_start	= ON;
	exinf	= 0x0;
};
task[]{
	entry_address	= clavierLcd();
	name	= id_clavierLcd;
	stack_size	= 256;
	stack_section	= stack;
	priority	= 10;
	initial_start	= ON;
	exinf	= 0x0;
};
task[]{
	entry_address	= attente_feu();
	name	= id_attente_feu;
	stack_size	= 256;
	stack_section	= stack;
	priority	= 9;
	initial_start	= ON;
	exinf	= 0x0;
};
task[]{
	entry_address	= strategie();
	name	= id_strategie;
	stack_size	= 256;
	stack_section	= stack;
	priority	= 9;
	initial_start	= ON;
	exinf	= 0x0;
};
task[]{
	entry_address	= ModeDeCourse();
	name	= id_ModeDeCourse;
	stack_size	= 256;
	stack_section	= stack;
	priority	= 9;
	initial_start	= ON;
	exinf	= 0x0;
};
task[]{
	entry_address	= capteur();
	name	= id_capteur;
	stack_size	= 256;
	stack_section	= stack;
	priority	= 9;
	initial_start	= ON;
	exinf	= 0x0;
};
task[]{
	entry_address	= definirParametre();
	name	= id_definirParametre;
	stack_size	= 256;
	stack_section	= stack;
	priority	= 9;
	initial_start	= ON;
	exinf	= 0x0;
};

flag[]{
	name	= ev_bus_fin_tr;
	initial_pattern	= 0x0000;
	wait_queue	= TA_TFIFO;
	clear_attribute	= YES;
	wait_multi	= TA_WMUL;
};
flag[]{
	name	= ev_periph;
	initial_pattern	= 0x0000;
	wait_queue	= TA_TFIFO;
	clear_attribute	= NO;
	wait_multi	= TA_WMUL;
};
flag[]{
	name	= event;
	initial_pattern	= 0x0000;
	wait_queue	= TA_TFIFO;
	clear_attribute	= NO;
	wait_multi	= TA_WMUL;
};


dataqueue[]{
	name	= CanTx;
	wait_queue	= TA_TFIFO;
	buffer_size	= 8;
};
dataqueue[]{
	name	= CanRx;
	wait_queue	= TA_TFIFO;
	buffer_size	= 4;
};




cyclic_hand[]{
	entry_address	= acqui();
	name	= ID_acqui;
	exinf	= 0x0;
	start	= OFF;
	phsatr	= OFF;
	interval_counter	= 0x64;
	phs_counter	= 0x0;
};
cyclic_hand[]{
	entry_address	= regulation();
	name	= id_regulation;
	exinf	= 0x0;
	start	= OFF;
	phsatr	= OFF;
	interval_counter	= 0x64;
	phs_counter	= 0x0;
};


vdataqueue[]{
	name	= QdmTouche;
	wait_queue	= TA_TFIFO;
	buffer_size	= 16;
};

interrupt_vector[8]{
	os_int	= YES;
	entry_address	= uart0_dma0_tr_OK();
	pragma_switch	= ;
};
interrupt_vector[17]{
	os_int	= YES;
	entry_address	= uart0_itx_ok();
	pragma_switch	= ;
};
interrupt_vector[18]{
	os_int	= YES;
	entry_address	= uart0_irx();
	pragma_switch	= ;
};
interrupt_vector[21]{
	os_int	= YES;
	entry_address	= mesure();
	pragma_switch	= ;
};
interrupt_vector[43]{
	os_int	= YES;
	entry_address	= itouche();
	pragma_switch	= ;
};



//
// End of Configuration
//
